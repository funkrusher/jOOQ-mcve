package org.jooq.mcve.test.java.mariadb;

import org.jooq.DSLContext;
import org.jooq.Record1;
import org.jooq.Record2;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.mariadb.tables.records.MainRecord;
import org.jooq.mcve.java.mariadb.tables.records.SubRecord;
import org.jooq.tools.JooqLogger;
import org.junit.*;
import org.testcontainers.containers.MariaDBContainer;
import org.testcontainers.shaded.com.fasterxml.jackson.core.JsonProcessingException;
import org.testcontainers.shaded.com.fasterxml.jackson.databind.ObjectMapper;
import org.testcontainers.utility.ResourceReaper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import static org.jooq.impl.DSL.*;
import static org.jooq.mcve.java.mariadb.Tables.MAIN;
import static org.jooq.mcve.java.mariadb.Tables.SUB;
import static org.junit.Assert.assertEquals;

public class JavaTest {

    static JooqLogger log = JooqLogger.getLogger(JavaTest.class);
    static MariaDBContainer<?> db;
    static Connection connection;
    static DSLContext ctx;
    static ObjectMapper jsonMapper;

    static final String CONNECTION_PARAMS = "?allowMultiQueries=true";

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("jooq.codegen.jdbc.url") == null) {
            db = new org.testcontainers.containers.MariaDBContainer<>("mariadb:latest")
                    .withUsername("root")
                    .withPassword("")
                    .withInitScript("db/migration/init.sql");
            db.start();
            System.setProperty("jooq.codegen.jdbc.url", db.getJdbcUrl());
            System.setProperty("jooq.codegen.jdbc.username", db.getUsername());
            System.setProperty("jooq.codegen.jdbc.password", db.getPassword());
        }

        log.info("Connecting");
        connection = DriverManager.getConnection(
                System.getProperty("jooq.codegen.jdbc.url") + CONNECTION_PARAMS,
                System.getProperty("jooq.codegen.jdbc.username"),
                System.getProperty("jooq.codegen.jdbc.password")
        );

        ctx = DSL.using(connection, SQLDialect.MARIADB);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }

        jsonMapper = new ObjectMapper();
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(SUB).execute();
        ctx.delete(MAIN).execute();

        // prepare test-data
        ctx.insertInto(MAIN)
                .columns(MAIN.CD, MAIN.MAINJSON)
                .values(42, getJsonDataStr())
                .execute();
        MainRecord mainRec = ctx.fetchOne(MAIN, MAIN.CD.eq(42));
        assert mainRec != null;
        ctx.insertInto(SUB)
                .columns(SUB.MAINID, SUB.SUBJSON)
                .values(mainRec.getMainid(), getJsonDataStr())
                .execute();
    }

    @After
    public void after() throws Exception {
    }

    @Test
    public void mcveTest() throws JsonProcessingException {
        final Record1<MainDTO> result = ctx.select(
                        row(
                                MAIN,
                                multiset(
                                        selectDistinct(
                                                SUB
                                        )
                                                .from(SUB)
                                                .where(SUB.MAINID.eq(MAIN.MAINID))
                                ).as("subMultiset").convertFrom(x -> x.map(SubDTO::create))
                        ).convertFrom(MainDTO::create)
                ).from(MAIN)
                .join(SUB).on(SUB.MAINID.eq(MAIN.MAINID))
                .fetchOne();

        assert result != null;
        assertEquals(getJsonDataStr(), result.value1().mainJson); // this works!
        assertEquals(getJsonDataStr(), result.value1().subs.getFirst().subJson); // this should work, but fails!
    }


    private static String getJsonDataStr() throws JsonProcessingException {
        // serialize some json.
        JsonData jsonData = new JsonData();
        jsonData.setTest1("test1");
        jsonData.setTest2("test2");
        jsonData.setInt1(42);
        return jsonMapper.writeValueAsString(jsonData);
    }

    private static final class MainDTO {
        private Integer mainId;
        private Integer cd;
        private String mainJson;

        private List<SubDTO> subs;

        public static MainDTO create(Record2<MainRecord, List<SubDTO>> rec) {
            MainDTO result = new MainDTO();
            result.mainId = rec.value1().getMainid();
            result.cd = rec.value1().getCd();
            result.mainJson = rec.value1().getMainjson();
            result.subs = rec.value2();
            return result;
        }
    }

    private static final class SubDTO {
        private Integer subId;
        private Integer mainId;

        private String subJson;

        public static SubDTO create(Record1<SubRecord> rec) {
            SubDTO result = new SubDTO();
            result.subId = rec.value1().getSubid();
            result.mainId = rec.value1().getMainid();
            result.subJson = rec.value1().getSubjson();
            return result;
        }
    }

    /**
     * JsonData
     * - pojo representing the JsonData content
     */
    private static final class JsonData {
        private String test1;
        private String test2;
        private Integer int1;

        public String getTest1() {
            return test1;
        }

        public void setTest1(String test1) {
            this.test1 = test1;
        }

        public String getTest2() {
            return test2;
        }

        public void setTest2(String test2) {
            this.test2 = test2;
        }

        public Integer getInt1() {
            return int1;
        }

        public void setInt1(Integer int1) {
            this.int1 = int1;
        }
    }
}
